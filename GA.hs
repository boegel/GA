{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}

-- |GA, a Haskell library for working with genetic algoritms
--
-- Aug. 2011 - Sept. 2011, by Kenneth Hoste
--
-- version: 0.2
module GA (Entity(..), 
           GAConfig(..), 
           evolve, 
           evolveVerbose) where

import Control.Monad (zipWithM)
import Control.Monad.IO.Class (MonadIO, liftIO)
import Data.List (sortBy, nub)
import Data.Maybe (catMaybes, fromJust, isJust)
import Data.Ord (comparing)
import System.Directory (createDirectoryIfMissing, doesFileExist)
import System.Random (StdGen, mkStdGen, randoms)

-- |Currify a list of elements into tuples.
currify :: [a] -- ^ list
           -> [(a,a)] -- ^ list of tuples
currify (x:y:xs) = (x,y):currify xs
currify [] = []
currify [_] = error "(currify) ERROR: only one element left?!?"

-- |Take and drop elements of a list in a single pass.
takeAndDrop :: Int -- ^ number of elements to take/drop
            -> [a] -- ^ list 
            -> ([a],[a]) -- ^ result: taken list element and rest of list
takeAndDrop n xs
        | n > 0     = let (hs,ts) = takeAndDrop (n-1) (tail xs) in (head xs:hs, ts)
        | otherwise = ([],xs)

-- |Configuration for genetic algorithm.
data GAConfig = GAConfig {
                -- |population size
                popSize :: Int, 
                -- |size of archive (best entities so far)
                archiveSize :: Int, 
                -- |maximum number of generations to evolve
                maxGenerations :: Int, 
                -- |fraction of entities generated by crossover (tip: >= 0.80)
                crossoverRate :: Float, 
                -- |fraction of entities generated by mutation (tip: <= 0.20)
                mutationRate :: Float, 
                -- |parameter for crossover (semantics depend on actual crossover operator)
                crossoverParam :: Float, 
                -- |parameter for mutation (semantics depend on actual mutation operator)
                mutationParam :: Float, 
                -- |enable/disable built-in checkpointing mechanism
                withCheckpointing :: Bool 
                }

-- |Type class for entities that represent a candidate solution.
--
-- Three parameters:
--
-- * data structure representing an entity (a)
--
-- * data used to score an entity, e.g. a list of numbers (b)
--
-- * some kind of pool used to generate random entities, e.g. a Hoogle database (c)
--
class (Eq e, Read e, Show e, Monad m) => Entity e d p m | e -> d, e -> p, e -> m where
  -- |Generate a random entity.
  genRandom :: p -> Int -> m e
  -- |Crossover operator: combine two entities into a new entity.
  crossover :: p -> Float -> Int -> e -> e -> m (Maybe e)
  -- |Mutation operator: mutate an entity into a new entity.
  mutation :: p -> Float -> Int -> e -> m (Maybe e)
  -- |Score an entity (lower is better).
  score' :: e -> d -> Double -- ^ pure scoring function
  score' _ _ = undefined
  score :: e -> d -> m Double -- ^ monadic scoring function
  score e d = do 
                 let s = score' e d
                 return s

-- |A possibly scored entity.
type ScoredEntity e = (Double, e)

-- |Scored generation (population and archive).
type Generation e = ([e],[ScoredEntity e])

-- |Initialize: generate initial population.
initPop :: (Entity e d p m) => p -- ^ pool for generating random entities
                            -> Int -- ^ population size
                            -> Int -- ^ random seed
                            -> m [e] -- ^ initialized population and remaining seeds
initPop pool n seed = do
                         let g = mkStdGen seed
                             seeds = take n $ randoms g
			 entities <- mapM (genRandom pool) seeds
                         return entities

-- |Score an entity (if it hasn't been already).
scoreEnt :: (Entity e d p m) => d -- ^ dataset for scoring entity
                             -> e -- ^ entity to score
                             -> m (ScoredEntity e) -- ^ scored entity
scoreEnt dataset e = do 
                        s <- score e dataset
                        return (s, e)

-- |Binary tournament selection operator.
tournamentSelection :: [ScoredEntity e] -- ^ set of entities to run selection on
                    -> Int -- ^ random seed
                    -> e -- ^ selected entity
tournamentSelection xs seed = if s1 < s2 then x1 else x2
  where
    len = length xs
    g = mkStdGen seed
    is = take 2 $ map (flip mod len) $ randoms g
    [(s1,x1),(s2,x2)] = map ((!!) xs) is

-- |Apply crossover to obtain new entites.
performCrossover :: (Entity e d p m) => Float -- ^ crossover parameter
                                     -> Int -- ^ number of entities to generate
                                     -> Int -- ^ random seed
                                     -> p -- ^ pool for combining entities
                                     -> [ScoredEntity e] -- ^ set of entities to run crossover on
                                     -> m [e] -- combined entities
performCrossover p n seed pool es = do 
                                       let g = mkStdGen seed
                                           (selSeeds,seeds) = takeAndDrop (2*2*n) $ randoms g
                                           (crossSeeds,_) = takeAndDrop (2*n) seeds
                                           tuples = currify $ map (tournamentSelection es) selSeeds
                                       resEntities <- zipWithM ($) (map (uncurry . (crossover pool p)) crossSeeds) $ tuples
                                       return $ take n $ catMaybes $ resEntities

-- |Apply mutation to obtain new entites.
performMutation :: (Entity e d p m) => Float -- ^ mutation parameter
                                    -> Int -- ^ number of entities to generate
                                    -> Int -- ^ random seed
                                    -> p -- ^ pool for mutating entities
                                    -> [ScoredEntity e] -- ^ set of entities to run mutation on
                                    -> m [e] -- mutated entities
performMutation p n seed pool es = do 
                                      let g = mkStdGen seed
                                          (selSeeds,seeds) = takeAndDrop (2*n) $ randoms g
                                          (mutSeeds,_) = takeAndDrop (2*n) seeds
                                      resEntities <- zipWithM ($) (map (mutation pool p) mutSeeds) $ map (tournamentSelection es) selSeeds
                                      return $ take n $ catMaybes $ resEntities

-- |Function to perform a single evolution step:
--
-- * score all entities in the population
--
-- * combine with best entities so far (archive)
--
-- * sort by fitness
--
-- * create new population using crossover/mutation
--
-- * retain best scoring entities in the archive
evolutionStep :: (Entity e d p m) => p -- ^ pool for crossover/mutation
                                  -> d -- ^ dataset for scoring entities
                                  -> (Int,Int,Int) -- ^ number of crossover/mutation/archive entities
                                  -> (Float,Float) -- ^ crossover/mutation parameters
                                  -> Generation e -- ^ current generation
                                  -> Int -- ^ seed for next generation
                                  -> m (Generation e) -- ^ next generation
evolutionStep pool dataset (cn,mn,an) (crossPar,mutPar) (pop,archive) seed = do 
                    -- score population
                    scoredPop <- mapM (scoreEnt dataset) pop
                    let 
                        -- combine with archive for selection
                        combo = scoredPop ++ archive
                        -- split seeds for crossover selection/seeds, mutation selection/seeds
                        g = mkStdGen seed
                        [crossSeed,mutSeed] = take 2 $ randoms g
                        -- apply crossover and mutation
                    crossEnts <- performCrossover crossPar cn crossSeed pool combo
                    mutEnts <- performMutation mutPar mn mutSeed pool combo
                    let -- new population: crossovered + mutated entities
                        pop' = crossEnts ++ mutEnts
                        -- new archive: best entities so far
                        archive' = take an $ nub $ sortBy (comparing fst) $ combo
                    return (pop',archive')

-- |Evolution: evaluate generation and continue.
evolution :: (Entity e d p m) => GAConfig -- ^ configuration for the genetic algorithm
                              -> Generation e -- ^ current generation
                              -> (Generation e -> Int -> m (Generation e)) -- actual evolution function, which evolves one generation
                              -> [(Int,Int)] -- ^ generation indicies and accompanying random seeds
                              -> m (Generation e) -- ^ resulting generation
evolution cfg generation step ((_,seed):gss) = do
                                                     nextGeneration <- step generation seed 
                                                     let (fitness, _) = (head $ snd nextGeneration)
                                                     if fitness == 0.0
                                                        then return nextGeneration
                                                        else evolution cfg nextGeneration step gss
-- no more gen. indices/seeds => quit
evolution _ generation _              []    = return generation

-- |Generate file name for checkpoint.
chkptFileName :: GAConfig -- ^ configuration for generation algorithm
              -> (Int,Int) -- ^ generation index and random seed
              -> FilePath -- ^ path of checkpoint file
chkptFileName cfg (gi,seed) = "checkpoints/GA-" ++ cfgTxt ++ "-gen" ++ (show gi) ++ "-seed-" ++ (show seed) ++ ".chk"
  where
    cfgTxt = (show $ popSize cfg) ++ "-" ++ 
             (show $ archiveSize cfg) ++ "-" ++
             (show $ crossoverRate cfg) ++ "-" ++
             (show $ mutationRate cfg) ++ "-" ++
             (show $ crossoverParam cfg) ++ "-" ++
             (show $ mutationParam cfg)

-- |Checkpoint a single generation.
checkpointGen :: (Entity e d p m) => GAConfig -- ^ configuraton for genetic algorithm
                                  -> Int -- ^ generation index
                                  -> Int -- ^ random seed for generation
                                  -> Generation e -- ^ current generation
                                  -> IO() -- ^ writes to file
checkpointGen cfg index seed (pop,archive) = do
                                           let txt = show $ (pop,archive)
                                               fn = chkptFileName cfg (index,seed)
                                           putStrLn $ "writing checkpoint for gen " ++ (show index) ++ " to " ++ fn
                                           createDirectoryIfMissing True "checkpoints"
                                           writeFile fn txt

-- |Evolution: evaluate generation, (maybe) checkpoint, continue.
evolutionChkpt :: (Entity e d p m, MonadIO m) => GAConfig -- ^ configuration for genetic algorithm
                                              -> Generation e -- ^ current generation
                                              -> (Generation e -> Int -> m (Generation e)) -- actual evolution function, which evolves one generation
                                              -> [(Int,Int)] -- ^ generation indicies and accompanying random seeds
                                              -> m (Generation e) -- ^ resulting generation
evolutionChkpt cfg (pop,archive) step ((gi,seed):gss) = do
                                                          newPa@(_,archive') <- step (pop,archive) seed
                                                          let (fitness, e) = head archive'
                                                          -- checkpoint generation if desired
                                                          liftIO $ if (withCheckpointing cfg)
                                                                      then checkpointGen cfg gi seed newPa
                                                                      else return () -- skip checkpoint
                                                          liftIO $ putStrLn $ "best entity (gen. " ++ show gi ++ "): " ++ (show e) ++ " [fitness: " ++ show fitness ++ "]"
                                                          -- check for perfect entity
                                                          if fitness == 0.0
                                                             then do 
                                                                     liftIO $ putStrLn $ "perfect entity found, finished after " ++ show gi ++ " generations!"
                                                                     return newPa
                                                             else evolutionChkpt cfg newPa step gss

-- no more gen. indices/seeds => quit
evolutionChkpt _   (pop,archive)   _           []     = do 
                                                           liftIO $ putStrLn $ "done evolving!"
                                                           return (pop,archive)

-- |Initialize.
initGA :: (Entity e d p m) => StdGen  -- ^ random generator
                           -> GAConfig -- ^ configuration for genetic algorithm
                           -> p -- ^ pool for generating random entities
                           -> m ([e],Int,Int,Int,Float,Float,[(Int,Int)]) -- ^ initialization result
initGA g cfg pool = do
                      -- generate list of random integers
                      let (seed:rs) = randoms g :: [Int]

                      -- initial population
                      pop <- initPop pool (popSize cfg) seed

                      let ps = popSize cfg
                          -- number of entities generated by crossover/mutation
                          cCnt = round $ (crossoverRate cfg) * (fromIntegral ps)
                          mCnt = round $ (mutationRate cfg) * (fromIntegral ps)
                          -- archive size
                          aSize = archiveSize cfg
                          -- crossover/mutation parameters
                          crossPar = crossoverParam cfg
                          mutPar = mutationParam cfg
                          --  seeds for evolution
                          seeds = take (maxGenerations cfg) rs
                          -- seeds per generation
                          genSeeds = zip [0..] seeds

                      return (pop, cCnt, mCnt, aSize, crossPar, mutPar, genSeeds)

-- |Extract the best entity from an archive.
extractBest :: [ScoredEntity e] -- ^ entity archive
            -> e -- ^ result is best entity from archive (lowest fitness)
extractBest archive 
	| null archive = error $ "(extractBest) empty archive!"
	| otherwise    = snd $ head $ sortBy (comparing fst) archive 

-- |Do the evolution!
evolve :: (Entity e d p m) => StdGen -- ^ random generator
                           -> GAConfig -- ^ configuration for genetic algorithm
                           -> p -- ^ pool for generating random entities (and also for crossover/mutation)
                           -> d -- ^ dataset required to score entities
                           -> m e -- ^ result is best entity found through evolution
evolve g cfg pool dataset = do
                -- initialize
                (pop, cCnt, mCnt, aSize, crossPar, mutPar, genSeeds) <- if not (withCheckpointing cfg)
                                                                           then initGA g cfg pool
                                                                           else error "(evolve) No checkpointing support (requires liftIO); see evolveVerbose."
                -- do the evolution
                (_,resArchive) <- evolution cfg (pop,[]) (evolutionStep pool dataset (cCnt,mCnt,aSize) (crossPar,mutPar)) genSeeds
                
               
	        -- return best entity
	        return (extractBest resArchive)

-- |Try to restore from checkpoint: first checkpoint for which a checkpoint file is found is restored.
restoreFromCheckpoint :: (Entity e d p m) => GAConfig -- ^ configuration for genetic algorithm
                                          -> [(Int,Int)] -- ^ generation indices and random seeds
                                          -> IO (Maybe (Int,Generation e)) -- ^ result is generation restored from checkpoint (if found, otherwise Nothing)
restoreFromCheckpoint cfg ((gi,seed):genSeeds) = do
                                                  chkptFound <- doesFileExist fn
                                                  if chkptFound 
                                                    then do
                                                          txt <- readFile fn
                                                          return $ Just (gi, read txt)
                                                    else restoreFromCheckpoint cfg genSeeds
  where
    fn = chkptFileName cfg (gi,seed)
restoreFromCheckpoint _ [] = return Nothing

-- |Do the evolution (support checkpointing). Requires support for liftIO in monad used.
evolveVerbose :: (Entity e d p m, MonadIO m) => StdGen -- ^ random generator
                                           -> GAConfig -- ^ configuration for genetic algorithm
                                           -> p -- ^ pool for generating random entities (and also for crossover/mutation)
                                           -> d -- ^ dataset required to score entities
                                           -> m e -- ^ result is best entity found through evolution
evolveVerbose g cfg pool dataset = do
                                   -- initialize
                                   (pop, cCnt, mCnt, aSize, crossPar, mutPar, genSeeds) <- initGA g cfg pool
                                   let checkpointing = withCheckpointing cfg

                                   -- (maybe) restore from checkpoint
                                   restored <- liftIO $ if checkpointing
                                                        then restoreFromCheckpoint cfg (reverse genSeeds) 
                                                        else return Nothing

                                   let (gi,(pop',archive')) = if isJust restored
                                          -- restored pop/archive from checkpoint
                                          then fromJust restored 
                                          -- restore failed, new population and empty archive
                                          else (-1, (pop, []))
                                       -- filter out seeds from past generations
                                       genSeeds' = filter ((>gi) . fst) genSeeds
                                   -- do the evolution
                                   (_,resArchive) <- evolutionChkpt cfg (pop',archive') (evolutionStep pool dataset (cCnt,mCnt,aSize) (crossPar,mutPar)) genSeeds'
               
				   -- return best entity 
                                   return (extractBest resArchive)
