{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE MultiParamTypeClasses #-}

-- |GA, a Haskell library for working with genetic algoritms
--
-- Aug. 2011 - Sept. 2011, by Kenneth Hoste
--
-- version: 0.2
module GA (Entity(..), 
           GAConfig(..), 
           evolve, 
           evolveChkpt) where

import Control.Monad.IO.Class (MonadIO, liftIO)
import Data.List (sortBy, nub)
import Data.Maybe (catMaybes, fromJust, isJust)
import Data.Ord (comparing)
import System.Directory (createDirectoryIfMissing, doesFileExist)
import System.Random (StdGen, mkStdGen, randoms)

-- |Currify a list of elements into tuples.
currify :: [a] -> [(a,a)]
currify (x:y:xs) = (x,y):currify xs
currify [] = []
currify [_] = error "(currify) ERROR: only one element left?!?"

-- |Take and drop elements of a list in a single pass.
takeAndDrop :: Int -> [a] -> ([a],[a])
takeAndDrop n xs
        | n > 0     = let (hs,ts) = takeAndDrop (n-1) (tail xs) in (head xs:hs, ts)
        | otherwise = ([],xs)


-- |Configuration for genetic algorithm.
data GAConfig = GAConfig {
                -- |population size
                popSize :: Int, 
                -- |size of archive (best entities so far)
                archiveSize :: Int, 
                -- |maximum number of generations to evolve
                maxGenerations :: Int, 
                -- |fraction of entities generated by crossover (tip: >= 0.80)
                crossoverRate :: Float, 
                -- |fraction of entities generated by mutation (tip: <= 0.20)
                mutationRate :: Float, 
                -- |parameter for crossover (semantics depend on actual crossover operator)
                crossoverParam :: Float, 
                -- |parameter for mutation (semantics depend on actual mutation operator)
                mutationParam :: Float, 
                -- |enable/disable built-in checkpointing mechanism
                withCheckpointing :: Bool 
                }

-- |Type class for entities that represent a candidate solution.
--
-- Three parameters:
--
-- * data structure representing an entity (a)
--
-- * data used to score an entity, e.g. a list of numbers (b)
--
-- * some kind of pool used to generate random entities, e.g. a Hoogle database (c)
--
class (Eq e, Read e, Show e, Monad m) => Entity e d p m | e -> d, e -> p, e -> m where
  -- |Generate a random entity.
  genRandom :: p -> Int -> e
  -- |Crossover operator: combine two entities into a new entity.
  crossover :: p -> Float -> Int -> e -> e -> Maybe e
  -- |Mutation operator: mutate an entity into a new entity.
  mutation :: p -> Float -> Int -> e -> Maybe e
  -- |Score an entity (lower is better).
  score' :: e -> d -> Double -- ^ pure
  score' _ _ = undefined
  score :: e -> d -> m Double -- ^ monadic
  score e d = do 
                 let s = score' e d
                 return s

-- |A possibly scored entity.
type ScoredEntity e = (Double, e)

-- |Scored generation (population and archive).
type Generation e = ([e],[ScoredEntity e])

-- |Initialize: generate initial population.
initPop :: (Entity e d p m) => p -> Int -> [Int] -> ([Int],[e])
initPop src n seeds = (seeds'', entities)
  where
    (seeds',seeds'')  = takeAndDrop n seeds
    entities = map (genRandom src) seeds'

-- |Score an entity (if it hasn't been already).
scoreEnt :: (Entity e d p m) => d -> e -> m (ScoredEntity e)
scoreEnt dataset e = do 
                        s <- score e dataset
                        return (s, e)

-- |Binary tournament selection operator.
tournamentSelection :: [ScoredEntity e] -> Int -> e
tournamentSelection xs seed = if s1 < s2 then x1 else x2
  where
    len = length xs
    g = mkStdGen seed
    is = take 2 $ map (flip mod len) $ randoms g
    [(s1,x1),(s2,x2)] = map ((!!) xs) is

-- |Function to perform a single evolution step:
--
-- * score all entities
--
-- * combine with best entities so far
--
-- * sort by fitness
--
-- * create new population using crossover/mutation
evolutionStep :: (Entity e d p m) => p -> d -> (Int,Int,Int) -> (Float,Float) -> Generation e -> Int -> m (Generation e)
evolutionStep src dataset (cn,mn,an) (crossPar,mutPar) (pop,archive) seed = do 
                    -- score population
                    scoredPop <- mapM (scoreEnt dataset) pop
                    let 
                        -- combine with archive for selection
                        combo = scoredPop ++ archive
                        -- split seeds for crossover selection/seeds, mutation selection/seeds
                        seeds = randoms (mkStdGen seed) :: [Int]
                        -- generate twice as many crossover/mutation entities as needed, because crossover/mutation can fail
                        (crossSelSeeds,seeds')   = takeAndDrop (2*2*cn) seeds
                        (crossSeeds   ,seeds'')  = takeAndDrop (2*cn) seeds'
                        (mutSelSeeds  ,seeds''') = takeAndDrop (2*mn) seeds''
                        (mutSeeds     ,_)        = takeAndDrop (2*mn) seeds'''
                        -- crossover entities
                        crossSel = currify $ map (tournamentSelection combo) crossSelSeeds
                        crossEnts = take cn $ catMaybes $ zipWith ($) (map (uncurry . (crossover src crossPar)) crossSeeds) crossSel
                        -- mutation entities
                        mutSel = map (tournamentSelection combo) mutSelSeeds
                        mutEnts = take cn $ catMaybes $ zipWith ($) (map (mutation src mutPar) mutSeeds) mutSel
                        -- new population: crossovered + mutated entities
                        pop' = crossEnts ++ mutEnts
                        -- new archive: best entities so far
                        archive' = take an $ nub $ sortBy (comparing fst) $ combo
                    return (pop',archive')

-- |Evolution: evaluate generation and continue.
evolution :: (Entity e d p m) => GAConfig -> Generation e -> (Generation e -> Int -> m (Generation e)) -> [(Int,Int)] -> m (Generation e)
evolution cfg (pop,archive) step ((_,seed):gss) = do
                                                     newPa@(_,archive') <- step (pop,archive) seed 
                                                     let (fitness, _) = head archive'
                                                     if fitness == 0.0
                                                        then return newPa
                                                        else evolution cfg newPa step gss
-- no more gen. indices/seeds => quit
evolution _ (pop,archive) _              []    = return (pop,archive)

-- |Generate file name for checkpoint.
chkptFileName :: GAConfig -> (Int,Int) -> FilePath
chkptFileName cfg (gi,seed) = "checkpoints/GA-" ++ cfgTxt ++ "-gen" ++ (show gi) ++ "-seed-" ++ (show seed) ++ ".chk"
  where
    cfgTxt = (show $ popSize cfg) ++ "-" ++ 
             (show $ archiveSize cfg) ++ "-" ++
             (show $ crossoverRate cfg) ++ "-" ++
             (show $ mutationRate cfg) ++ "-" ++
             (show $ crossoverParam cfg) ++ "-" ++
             (show $ mutationParam cfg)

-- |Checkpoint a single generation.
checkpointGen :: (Entity e d p m) => GAConfig -> Int -> Int -> Generation e -> IO()
checkpointGen cfg index seed (pop,archive) = do
                                           let txt = show $ (pop,archive)
                                               fn = chkptFileName cfg (index,seed)
                                           putStrLn $ "writing checkpoint for gen " ++ (show index) ++ " to " ++ fn
                                           createDirectoryIfMissing True "checkpoints"
                                           writeFile fn txt

-- |Evolution: evaluate generation, (maybe) checkpoint, continue.
evolutionChkpt :: (Entity e d p m, MonadIO m) => GAConfig -> Generation e -> (Generation e -> Int -> m (Generation e)) -> [(Int,Int)] -> m (Generation e)
evolutionChkpt cfg (pop,archive) step ((gi,seed):gss) = do
                                                          newPa@(_,archive') <- step (pop,archive) seed
                                                          let (fitness, e) = head archive'
                                                          -- checkpoint generation if desired
                                                          liftIO $ if (withCheckpointing cfg)
                                                                      then checkpointGen cfg gi seed newPa
                                                                      else return () -- skip checkpoint
                                                          liftIO $ putStrLn $ "best entity (gen. " ++ show gi ++ "): " ++ (show e) ++ " [fitness: " ++ show fitness ++ "]"
                                                          -- check for perfect entity
                                                          if fitness == 0.0
                                                             then do 
                                                                     liftIO $ putStrLn $ "perfect entity found, finished after " ++ show gi ++ " generations!"
                                                                     return newPa
                                                             else evolutionChkpt cfg newPa step gss

-- no more gen. indices/seeds => quit
evolutionChkpt _   (pop,archive)   _           []     = do 
                                                           liftIO $ putStrLn $ "done evolving!"
                                                           return (pop,archive)

-- |Initialize.
initGA :: (Entity e d p m) => StdGen -> GAConfig -> p -> ([e],Int,Int,Int,Float,Float,[(Int,Int)])
initGA g cfg src = (pop, cCnt, mCnt, aSize, crossPar, mutPar, genSeeds)
  where
    -- generate list of random integers
    rs = randoms g :: [Int]

    -- initial population
    (rs',pop) = initPop src (popSize cfg) rs

    ps = popSize cfg
    -- number of entities generated by crossover/mutation
    cCnt = round $ (crossoverRate cfg) * (fromIntegral ps)
    mCnt = round $ (mutationRate cfg) * (fromIntegral ps)
    -- archive size
    aSize = archiveSize cfg
    -- crossover/mutation parameters
    crossPar = crossoverParam cfg
    mutPar = mutationParam cfg
    --  seeds for evolution
    seeds = take (maxGenerations cfg) rs'
    -- seeds per generation
    genSeeds = zip [0..] seeds

-- |Extract the best entity from an archive.
extractBest :: [ScoredEntity e] -> e
extractBest archive 
	| null archive = error $ "(extractBest) empty archive!"
	| otherwise    = snd $ head archive 

-- |Do the evolution!
evolve :: (Entity e d p m) => StdGen -> GAConfig -> p -> d -> m e
evolve g cfg src dataset = do
                -- initialize
                let (pop, cCnt, mCnt, aSize, crossPar, mutPar, genSeeds) = if not (withCheckpointing cfg)
                                                                              then initGA g cfg src
                                                                              else error "(evolve) No checkpointing support because it requires liftIO; see evolveChkpt."
                -- do the evolution
                (_,resArchive) <- evolution cfg (pop,[]) (evolutionStep src dataset (cCnt,mCnt,aSize) (crossPar,mutPar)) genSeeds
                
               
	        -- return best entity
	        return (extractBest resArchive)

-- |Try to restore from checkpoint: first checkpoint for which a checkpoint file is found is restored.
restoreFromCheckpoint :: (Entity e d p m) => GAConfig -> [(Int,Int)] -> IO (Maybe (Int,Generation e))
restoreFromCheckpoint cfg ((gi,seed):genSeeds) = do
                                                  chkptFound <- doesFileExist fn
                                                  if chkptFound 
                                                    then do
                                                          txt <- readFile fn
                                                          return $ Just (gi, read txt)
                                                    else restoreFromCheckpoint cfg genSeeds
  where
    fn = chkptFileName cfg (gi,seed)
restoreFromCheckpoint _ [] = return Nothing

-- |Do the evolution (support checkpointing). Requires support for liftIO in monad used.
evolveChkpt :: (Entity e d p m, MonadIO m) => StdGen -> GAConfig -> p -> d -> m e
evolveChkpt g cfg src dataset = do
                                   -- initialize
                                   let (pop, cCnt, mCnt, aSize, crossPar, mutPar, genSeeds) = initGA g cfg src
                                       checkpointing = withCheckpointing cfg

                                   -- (maybe) restore from checkpoint
                                   restored <- liftIO $ if checkpointing
                                                        then restoreFromCheckpoint cfg (reverse genSeeds) 
                                                        else return Nothing

                                   let (gi,(pop',archive')) = if isJust restored
                                          -- restored pop/archive from checkpoint
                                          then fromJust restored 
                                          -- restore failed, new population and empty archive
                                          else (-1, (pop, []))
                                       -- filter out seeds from past generations
                                       genSeeds' = filter ((>gi) . fst) genSeeds
                                   -- do the evolution
                                   (_,resArchive) <- evolutionChkpt cfg (pop',archive') (evolutionStep src dataset (cCnt,mCnt,aSize) (crossPar,mutPar)) genSeeds'
               
				   -- return best entity 
                                   return (extractBest resArchive)
